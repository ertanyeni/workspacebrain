"""Context file generation module for cross-project AI awareness."""

from datetime import datetime
from pathlib import Path
from typing import Optional

from ..models import AISessionEntry, BrainConfig
from .log_parser import LogParser


class ContextGenerator:
    """Generates context files from logs for AI assistants to read."""

    def __init__(self, config: BrainConfig):
        self.config = config
        self.parser = LogParser(config)

    def refresh_all_context(self, days: int = 3) -> dict[str, Path]:
        """Regenerate all context files.

        Returns dict of generated file paths.
        """
        context_dir = self.config.context_path
        context_dir.mkdir(parents=True, exist_ok=True)

        generated = {}

        # Generate RECENT_ACTIVITY.md
        recent_path = context_dir / "RECENT_ACTIVITY.md"
        recent_content = self.generate_recent_activity(days)
        recent_path.write_text(recent_content)
        generated["recent_activity"] = recent_path

        # Generate OPEN_QUESTIONS.md
        questions_path = context_dir / "OPEN_QUESTIONS.md"
        questions_content = self.generate_open_questions(days)
        questions_path.write_text(questions_content)
        generated["open_questions"] = questions_path

        return generated

    def generate_recent_activity(self, days: int = 3) -> str:
        """Generate RECENT_ACTIVITY.md content from recent logs."""
        entries = self.parser.get_logs_in_range(days)
        now = datetime.now()

        lines = [
            "# Recent Workspace Activity",
            f"*Auto-generated: {now.strftime('%Y-%m-%d %H:%M')}*",
            "",
            f"## Last {days * 24} Hours Summary",
            "",
        ]

        if not entries:
            lines.extend([
                "*No recent AI sessions logged.*",
                "",
                "To log a session, use:",
                "```bash",
                'wbrain ai-log -p "project" -t "claude" -s "What was done"',
                "```",
            ])
            return "\n".join(lines)

        # Group entries by project
        by_project: dict[str, list[AISessionEntry]] = {}
        for entry in entries:
            if entry.project_name not in by_project:
                by_project[entry.project_name] = []
            by_project[entry.project_name].append(entry)

        # Generate project sections
        for project, project_entries in by_project.items():
            # Get project type from first entry
            project_type = project_entries[0].project_type
            lines.append(f"### {project} ({project_type})")
            lines.append("")

            for entry in project_entries:
                timestamp = entry.timestamp.strftime("%Y-%m-%d %H:%M")
                lines.append(f"- **{timestamp}** ({entry.ai_tool}) {entry.summary}")

                # Show related projects if any
                if entry.related_projects:
                    for rel_project, reason in entry.related_projects.items():
                        lines.append(f"  - Related to **{rel_project}**: {reason}")

                # Show open questions inline
                if entry.open_questions:
                    lines.append(f"  - Open: {'; '.join(entry.open_questions[:2])}")

            lines.append("")

        # Add cross-project relationships section
        relationships = self.parser.extract_project_relationships(entries)
        if relationships:
            lines.extend([
                "## Project Relationships",
                "",
            ])
            for project, related in relationships.items():
                if related:
                    lines.append(f"- **{project}** <-> {', '.join(related)}")
            lines.append("")

        # Add summary of all open questions
        all_questions = self.parser.extract_open_questions(entries)
        if all_questions:
            lines.extend([
                "## Open Questions Across Projects",
                "",
            ])
            for q in all_questions[:10]:  # Limit to 10 questions
                lines.append(f"- [{q['project']}] {q['question']}")
            lines.append("")

        # Add footer
        lines.extend([
            "---",
            f"*Generated by WorkspaceBrain from last {days} days of logs.*",
        ])

        return "\n".join(lines)

    def generate_open_questions(self, days: int = 3) -> str:
        """Generate OPEN_QUESTIONS.md from recent sessions."""
        entries = self.parser.get_logs_in_range(days)
        questions = self.parser.extract_open_questions(entries)
        now = datetime.now()

        lines = [
            "# Open Questions",
            f"*Auto-generated: {now.strftime('%Y-%m-%d %H:%M')}*",
            "",
        ]

        if not questions:
            lines.extend([
                "*No open questions in recent sessions.*",
                "",
                "When logging AI sessions, add open questions to track decisions needed:",
                "```bash",
                'wbrain ai-log -s "..." -q "Should we use X or Y?"',
                "```",
            ])
            return "\n".join(lines)

        # Group questions by project
        by_project: dict[str, list[dict]] = {}
        for q in questions:
            if q["project"] not in by_project:
                by_project[q["project"]] = []
            by_project[q["project"]].append(q)

        for project, project_questions in by_project.items():
            lines.append(f"## {project}")
            lines.append("")
            for q in project_questions:
                timestamp = q["timestamp"][:10]  # Just date
                lines.append(f"- [ ] {q['question']} ({timestamp}, {q['ai_tool']})")
            lines.append("")

        lines.extend([
            "---",
            "*Mark questions as [x] when resolved.*",
        ])

        return "\n".join(lines)

    def get_context_for_project(
        self, project_name: str, days: int = 3
    ) -> Optional[str]:
        """Get context specifically relevant to a project.

        This can be used to inject project-specific context into AI rule files.
        """
        entries = self.parser.get_logs_in_range(days)

        # Find entries related to this project
        relevant_entries = []
        for entry in entries:
            # Include if this project or if related to this project
            if entry.project_name == project_name:
                relevant_entries.append(("direct", entry))
            elif project_name in entry.related_projects:
                relevant_entries.append(("related", entry))

        if not relevant_entries:
            return None

        lines = [
            f"## Recent Context for {project_name}",
            "",
        ]

        for relation, entry in relevant_entries[:5]:  # Limit to 5 entries
            timestamp = entry.timestamp.strftime("%Y-%m-%d %H:%M")
            if relation == "direct":
                lines.append(f"- **{timestamp}** {entry.summary}")
            else:
                reason = entry.related_projects.get(project_name, "Related")
                lines.append(
                    f"- **{timestamp}** [{entry.project_name}] {entry.summary}"
                )
                lines.append(f"  - Impact on {project_name}: {reason}")

        return "\n".join(lines)
