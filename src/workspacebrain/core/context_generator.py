"""Context file generation module for cross-project AI awareness."""

from datetime import datetime
from pathlib import Path
from typing import Optional

from ..models import AISessionEntry, BrainConfig
from .log_parser import LogParser
from .relationship_manager import RelationshipManager


class ContextGenerator:
    """Generates context files from logs for AI assistants to read.

    Supports two modes:
    1. Global context: RECENT_ACTIVITY.md with all projects (legacy)
    2. Project-specific context: projects/{project}.md with only related projects
    """

    def __init__(self, config: BrainConfig):
        self.config = config
        self.parser = LogParser(config)
        self.relationship_manager = RelationshipManager(config)

    def refresh_all_context(self, days: int = 3) -> dict[str, Path]:
        """Regenerate all context files.

        Returns dict of generated file paths.
        """
        context_dir = self.config.context_path
        context_dir.mkdir(parents=True, exist_ok=True)

        generated = {}

        # Generate RECENT_ACTIVITY.md
        recent_path = context_dir / "RECENT_ACTIVITY.md"
        recent_content = self.generate_recent_activity(days)
        recent_path.write_text(recent_content)
        generated["recent_activity"] = recent_path

        # Generate OPEN_QUESTIONS.md
        questions_path = context_dir / "OPEN_QUESTIONS.md"
        questions_content = self.generate_open_questions(days)
        questions_path.write_text(questions_content)
        generated["open_questions"] = questions_path

        return generated

    def generate_recent_activity(self, days: int = 3) -> str:
        """Generate RECENT_ACTIVITY.md content from recent logs."""
        entries = self.parser.get_logs_in_range(days)
        now = datetime.now()

        lines = [
            "# Recent Workspace Activity",
            f"*Auto-generated: {now.strftime('%Y-%m-%d %H:%M')}*",
            "",
            f"## Last {days * 24} Hours Summary",
            "",
        ]

        if not entries:
            lines.extend([
                "*No recent AI sessions logged.*",
                "",
                "To log a session, use:",
                "```bash",
                'wbrain ai-log -p "project" -t "claude" -s "What was done"',
                "```",
            ])
            return "\n".join(lines)

        # Group entries by project
        by_project: dict[str, list[AISessionEntry]] = {}
        for entry in entries:
            if entry.project_name not in by_project:
                by_project[entry.project_name] = []
            by_project[entry.project_name].append(entry)

        # Generate project sections
        for project, project_entries in by_project.items():
            # Get project type from first entry
            project_type = project_entries[0].project_type
            lines.append(f"### {project} ({project_type})")
            lines.append("")

            for entry in project_entries:
                timestamp = entry.timestamp.strftime("%Y-%m-%d %H:%M")
                lines.append(f"- **{timestamp}** ({entry.ai_tool}) {entry.summary}")

                # Show related projects if any
                if entry.related_projects:
                    for rel_project, reason in entry.related_projects.items():
                        lines.append(f"  - Related to **{rel_project}**: {reason}")

                # Show open questions inline
                if entry.open_questions:
                    lines.append(f"  - Open: {'; '.join(entry.open_questions[:2])}")

            lines.append("")

        # Add cross-project relationships section
        relationships = self.parser.extract_project_relationships(entries)
        if relationships:
            lines.extend([
                "## Project Relationships",
                "",
            ])
            for project, related in relationships.items():
                if related:
                    lines.append(f"- **{project}** <-> {', '.join(related)}")
            lines.append("")

        # Add summary of all open questions
        all_questions = self.parser.extract_open_questions(entries)
        if all_questions:
            lines.extend([
                "## Open Questions Across Projects",
                "",
            ])
            for q in all_questions[:10]:  # Limit to 10 questions
                lines.append(f"- [{q['project']}] {q['question']}")
            lines.append("")

        # Add footer
        lines.extend([
            "---",
            f"*Generated by WorkspaceBrain from last {days} days of logs.*",
        ])

        return "\n".join(lines)

    def generate_open_questions(self, days: int = 3) -> str:
        """Generate OPEN_QUESTIONS.md from recent sessions."""
        entries = self.parser.get_logs_in_range(days)
        questions = self.parser.extract_open_questions(entries)
        now = datetime.now()

        lines = [
            "# Open Questions",
            f"*Auto-generated: {now.strftime('%Y-%m-%d %H:%M')}*",
            "",
        ]

        if not questions:
            lines.extend([
                "*No open questions in recent sessions.*",
                "",
                "When logging AI sessions, add open questions to track decisions needed:",
                "```bash",
                'wbrain ai-log -s "..." -q "Should we use X or Y?"',
                "```",
            ])
            return "\n".join(lines)

        # Group questions by project
        by_project: dict[str, list[dict]] = {}
        for q in questions:
            if q["project"] not in by_project:
                by_project[q["project"]] = []
            by_project[q["project"]].append(q)

        for project, project_questions in by_project.items():
            lines.append(f"## {project}")
            lines.append("")
            for q in project_questions:
                timestamp = q["timestamp"][:10]  # Just date
                lines.append(f"- [ ] {q['question']} ({timestamp}, {q['ai_tool']})")
            lines.append("")

        lines.extend([
            "---",
            "*Mark questions as [x] when resolved.*",
        ])

        return "\n".join(lines)

    def get_context_for_project(
        self, project_name: str, days: int = 3
    ) -> Optional[str]:
        """Get context specifically relevant to a project.

        This can be used to inject project-specific context into AI rule files.
        """
        entries = self.parser.get_logs_in_range(days)

        # Find entries related to this project
        relevant_entries = []
        for entry in entries:
            # Include if this project or if related to this project
            if entry.project_name == project_name:
                relevant_entries.append(("direct", entry))
            elif project_name in entry.related_projects:
                relevant_entries.append(("related", entry))

        if not relevant_entries:
            return None

        lines = [
            f"## Recent Context for {project_name}",
            "",
        ]

        for relation, entry in relevant_entries[:5]:  # Limit to 5 entries
            timestamp = entry.timestamp.strftime("%Y-%m-%d %H:%M")
            if relation == "direct":
                lines.append(f"- **{timestamp}** {entry.summary}")
            else:
                reason = entry.related_projects.get(project_name, "Related")
                lines.append(
                    f"- **{timestamp}** [{entry.project_name}] {entry.summary}"
                )
                lines.append(f"  - Impact on {project_name}: {reason}")

        return "\n".join(lines)

    def refresh_project_contexts(self, days: int = 3) -> dict[str, Path]:
        """Generate project-specific context files in CONTEXT/projects/.

        Each project gets a context file containing only:
        - Its own activity
        - Activity from related projects

        Returns dict mapping project_name -> generated file path.
        """
        # First, refresh relationships from logs
        self.relationship_manager.refresh_from_logs(days)

        # Create projects directory
        projects_dir = self.config.context_projects_path
        projects_dir.mkdir(parents=True, exist_ok=True)

        generated = {}
        entries = self.parser.get_logs_in_range(days)

        # Get all unique projects from entries
        all_projects: set[str] = set()
        for entry in entries:
            all_projects.add(entry.project_name)
            all_projects.update(entry.related_projects.keys())

        # Generate context file for each project
        for project_name in all_projects:
            content = self._generate_project_context(project_name, entries, days)
            context_path = projects_dir / f"{project_name}.md"
            context_path.write_text(content, encoding="utf-8")
            generated[project_name] = context_path

        return generated

    def _generate_project_context(
        self, project_name: str, all_entries: list[AISessionEntry], days: int
    ) -> str:
        """Generate context content for a specific project.

        Only includes:
        - This project's own activity
        - Activity from directly related projects
        """
        now = datetime.now()

        # Get related projects
        related_projects = self.relationship_manager.get_related_projects(project_name)
        context_projects = {project_name} | related_projects

        lines = [
            f"# Context for {project_name}",
            f"*Auto-generated: {now.strftime('%Y-%m-%d %H:%M')}*",
            "",
        ]

        # Filter entries to only include relevant projects
        relevant_entries = [
            e for e in all_entries if e.project_name in context_projects
        ]

        if not relevant_entries:
            lines.extend([
                f"*No recent activity for {project_name} or related projects.*",
                "",
                "Related projects: " + (", ".join(sorted(related_projects)) if related_projects else "None discovered yet"),
                "",
                "To log a session:",
                "```bash",
                f'wbrain ai-log -p "{project_name}" -t "claude" -s "What was done"',
                "```",
            ])
            return "\n".join(lines)

        # Show related projects
        if related_projects:
            lines.extend([
                "## Related Projects",
                "",
                "This context includes activity from:",
                f"- **{project_name}** (this project)",
            ])
            for rp in sorted(related_projects):
                lines.append(f"- {rp}")
            lines.append("")

        # Group entries by project
        by_project: dict[str, list[AISessionEntry]] = {}
        for entry in relevant_entries:
            if entry.project_name not in by_project:
                by_project[entry.project_name] = []
            by_project[entry.project_name].append(entry)

        # Show this project's activity first
        if project_name in by_project:
            lines.append(f"## {project_name} (This Project)")
            lines.append("")
            for entry in by_project[project_name]:
                self._append_entry_summary(lines, entry)
            lines.append("")

        # Show related projects' activity
        for rp in sorted(related_projects):
            if rp in by_project:
                lines.append(f"## {rp}")
                lines.append("")
                for entry in by_project[rp]:
                    self._append_entry_summary(lines, entry, highlight_for=project_name)
                lines.append("")

        # Show open questions relevant to this project
        relevant_questions = []
        for entry in relevant_entries:
            for q in entry.open_questions:
                relevant_questions.append({
                    "project": entry.project_name,
                    "question": q,
                    "timestamp": entry.timestamp.strftime("%Y-%m-%d"),
                })

        if relevant_questions:
            lines.extend([
                "## Open Questions",
                "",
            ])
            for q in relevant_questions[:5]:  # Limit to 5
                lines.append(f"- [{q['project']}] {q['question']}")
            lines.append("")

        lines.extend([
            "---",
            f"*Filtered context for {project_name}. Only includes related projects.*",
        ])

        return "\n".join(lines)

    def _append_entry_summary(
        self,
        lines: list[str],
        entry: AISessionEntry,
        highlight_for: Optional[str] = None,
    ) -> None:
        """Append a formatted entry summary to lines."""
        timestamp = entry.timestamp.strftime("%Y-%m-%d %H:%M")
        lines.append(f"- **{timestamp}** ({entry.ai_tool}) {entry.summary}")

        # If highlighting for a specific project, show why it's relevant
        if highlight_for and highlight_for in entry.related_projects:
            reason = entry.related_projects[highlight_for]
            lines.append(f"  - Impact on {highlight_for}: {reason}")

        # Show key files if any
        if entry.key_files:
            files_str = ", ".join(f"`{f}`" for f in entry.key_files[:3])
            lines.append(f"  - Files: {files_str}")

    def refresh_all_project_contexts(self, days: int = 3) -> dict[str, Path]:
        """Refresh both global and project-specific contexts.

        Returns combined dict of all generated files.
        """
        generated = self.refresh_all_context(days)
        project_contexts = self.refresh_project_contexts(days)

        for project_name, path in project_contexts.items():
            generated[f"project:{project_name}"] = path

        return generated
