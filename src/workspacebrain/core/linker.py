"""Brain linker module - creates .brain symlinks and AI rule files in projects."""

import json
import os
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Optional

import yaml

from workspacebrain import __version__
from workspacebrain.models import BrainConfig, BrainManifest


# Generated file banner
GENERATED_BANNER = """# ============================================================================
# GENERATED BY WORKSPACEBRAIN â€” DO NOT EDIT
# This file is auto-generated from brain/RULES/ templates.
# Any manual changes will be overwritten on next `workspacebrain link`.
# To customize, edit the source template in brain/RULES/
# ============================================================================

"""

# AI rule files to generate in each project
AI_RULE_FILES = ["CLAUDE.md", "CURSOR_RULES.md", "AI.md"]


@dataclass
class LinkResult:
    """Result of a brain linking operation."""

    success: bool
    error: Optional[str] = None
    linked_projects: list[str] = field(default_factory=list)
    skipped_projects: list[str] = field(default_factory=list)
    generated_files: list[str] = field(default_factory=list)
    symlink_fallbacks: list[str] = field(default_factory=list)


class BrainLinker:
    """Handles linking projects to the central brain directory."""

    BRAIN_POINTER = ".brain"
    BRAIN_LINK_DIR = ".brain"
    BRAIN_LINK_FILE = "brain.link.json"

    def __init__(self, config: BrainConfig) -> None:
        self.config = config

    def link_all(self) -> LinkResult:
        """Link all detected projects to the brain.

        For each project:
        1. Creates .brain symlink to ../../brain (relative path)
        2. If symlink fails, creates .brain/brain.link.json fallback
        3. Generates AI rule files (CLAUDE.md, CURSOR_RULES.md, AI.md)
        """
        result = LinkResult(success=True)

        try:
            # Check if brain exists
            if not self.config.brain_path.exists():
                result.success = False
                result.error = f"Brain not found at {self.config.brain_path}. Run 'init' first."
                return result

            # Load manifest to get projects
            manifest = self._load_manifest()
            if manifest is None:
                result.success = False
                result.error = "MANIFEST.yaml not found or invalid. Run 'init' and 'scan' first."
                return result

            if not manifest.detected_projects:
                result.success = True
                return result

            # Link each project
            for project in manifest.detected_projects:
                project_path = Path(project.path)
                if project_path.exists():
                    self._link_project(project_path, project.project_type, result)
                else:
                    result.skipped_projects.append(f"{project.name} (path not found)")

        except Exception as e:
            result.success = False
            result.error = str(e)

        return result

    def link_project(self, project_path: Path, project_type: str = "unknown") -> LinkResult:
        """Link a single project to the brain."""
        result = LinkResult(success=True)

        try:
            if not self.config.brain_path.exists():
                result.success = False
                result.error = f"Brain not found at {self.config.brain_path}"
                return result

            self._link_project(project_path, project_type, result)

        except Exception as e:
            result.success = False
            result.error = str(e)

        return result

    def _link_project(
        self, project_path: Path, project_type: str, result: LinkResult
    ) -> None:
        """Create .brain symlink and AI rule files in the project directory."""
        project_name = project_path.name

        # Step 1: Create .brain symlink or fallback
        link_created = self._create_brain_link(project_path, result)

        if link_created:
            result.linked_projects.append(project_name)

            # Step 2: Generate AI rule files
            self._generate_ai_rule_files(project_path, project_type, result)
        elif not self.config.force:
            result.skipped_projects.append(project_name)

    def _create_brain_link(self, project_path: Path, result: LinkResult) -> bool:
        """Create .brain symlink, with fallback to .brain/brain.link.json."""
        symlink_path = project_path / self.BRAIN_POINTER
        project_name = project_path.name

        # Calculate relative path from project to brain
        # e.g., if project is /workspace/backend-api and brain is /workspace/brain
        # relative path should be ../brain
        try:
            # Get relative path from project dir to brain dir
            relative_brain_path = os.path.relpath(
                self.config.brain_path, project_path
            )
        except ValueError:
            # Cross-device or other issues, use absolute
            relative_brain_path = str(self.config.brain_path)

        # Check if symlink already exists and points to correct location
        if symlink_path.is_symlink():
            current_target = os.readlink(symlink_path)
            if current_target == relative_brain_path:
                if not self.config.force:
                    return False  # Already correctly linked
            # Remove old symlink if forcing or target is wrong
            symlink_path.unlink()
        elif symlink_path.exists():
            # It's a file or directory, not a symlink
            if symlink_path.is_dir():
                # Check if it's our fallback directory
                link_json = symlink_path / self.BRAIN_LINK_FILE
                if link_json.exists() and not self.config.force:
                    return False  # Already has fallback
            if self.config.force:
                if symlink_path.is_dir():
                    import shutil
                    shutil.rmtree(symlink_path)
                else:
                    symlink_path.unlink()
            else:
                return False  # Don't overwrite existing non-symlink

        # Try to create symlink
        try:
            symlink_path.symlink_to(relative_brain_path)
            return True
        except OSError:
            # Symlink failed (permissions, filesystem doesn't support, etc.)
            # Fall back to .brain/brain.link.json
            return self._create_fallback_link(project_path, project_name, result)

    def _create_fallback_link(
        self, project_path: Path, project_name: str, result: LinkResult
    ) -> bool:
        """Create .brain/brain.link.json fallback when symlink fails."""
        brain_dir = project_path / self.BRAIN_LINK_DIR
        link_file = brain_dir / self.BRAIN_LINK_FILE

        try:
            brain_dir.mkdir(exist_ok=True)

            link_data = {
                "brain_path": str(self.config.brain_path),
                "brain_version": "1.0",
                "workspacebrain_version": __version__,
                "created_at": datetime.now().isoformat(),
                "note": "Fallback link file. Symlink creation failed.",
            }

            link_file.write_text(
                json.dumps(link_data, indent=2), encoding="utf-8"
            )

            result.symlink_fallbacks.append(project_name)
            return True

        except Exception:
            return False

    def _generate_ai_rule_files(
        self, project_path: Path, project_type: str, result: LinkResult
    ) -> None:
        """Generate AI rule files (CLAUDE.md, CURSOR_RULES.md, AI.md) in project."""
        for rule_file in AI_RULE_FILES:
            self._generate_rule_file(project_path, project_type, rule_file, result)

    def _generate_rule_file(
        self,
        project_path: Path,
        project_type: str,
        rule_file: str,
        result: LinkResult,
    ) -> None:
        """Generate a single AI rule file from brain/RULES/ template."""
        output_path = project_path / rule_file

        # Skip if exists and not forcing
        if output_path.exists() and not self.config.force:
            return

        # Load template content from brain/RULES/
        template_content = self._load_rule_template(rule_file, project_type)

        # Write with generated banner
        content = GENERATED_BANNER + template_content
        output_path.write_text(content, encoding="utf-8")

        result.generated_files.append(f"{project_path.name}/{rule_file}")

    def _load_rule_template(self, rule_file: str, project_type: str) -> str:
        """Load rule template from brain/RULES/ directory.

        Tries project-type specific template first, then generic.
        e.g., for CLAUDE.md and python-be:
          1. brain/RULES/CLAUDE.python-be.md
          2. brain/RULES/CLAUDE.md
          3. Default template
        """
        rules_path = self.config.rules_path

        # Try type-specific template
        type_specific = rules_path / f"{rule_file.replace('.md', '')}.{project_type}.md"
        if type_specific.exists():
            return type_specific.read_text(encoding="utf-8")

        # Try generic template
        generic = rules_path / rule_file
        if generic.exists():
            return generic.read_text(encoding="utf-8")

        # Return default template
        return self._get_default_rule_template(rule_file, project_type)

    def _get_default_rule_template(self, rule_file: str, project_type: str) -> str:
        """Get default rule template content."""
        workspace_name = self.config.workspace_path.name
        brain_path = self.config.brain_path

        if rule_file == "CLAUDE.md":
            return f"""# Claude Instructions for {workspace_name}

## Project Context

This is a **{project_type}** project in the {workspace_name} workspace.

## Brain Location

Central brain directory: `{brain_path}`

Read the following files for workspace-wide context:
- `brain/DECISIONS.md` - Architectural decisions
- `brain/CONTRACTS/` - API contracts
- `brain/RULES/` - Coding standards

## Coding Standards

1. Follow existing code patterns in this project
2. Write clear, self-documenting code
3. Add tests for new functionality
4. Update documentation when changing APIs

## Before Making Changes

1. Check DECISIONS.md for relevant architectural decisions
2. Review any related contracts in CONTRACTS/
3. Ensure changes align with workspace conventions
"""

        elif rule_file == "CURSOR_RULES.md":
            return f"""# Cursor Rules for {workspace_name}

## Project Type: {project_type}

## Workspace Brain

This project is part of the **{workspace_name}** workspace.
Central knowledge is stored in: `{brain_path}`

## Key Files to Reference

- `brain/MANIFEST.yaml` - Project registry
- `brain/DECISIONS.md` - Architecture decisions
- `brain/RULES/INDEX.md` - Coding standards index

## Code Generation Guidelines

1. Match existing code style in the project
2. Use established patterns from the codebase
3. Prefer simple solutions over clever ones
4. Add comments only for non-obvious logic
"""

        else:  # AI.md
            return f"""# AI Assistant Instructions

## Workspace: {workspace_name}
## Project Type: {project_type}

## Context

This project is managed by WorkspaceBrain.
Central knowledge repository: `{brain_path}`

## Important Files

| File | Purpose |
|------|---------|
| brain/MANIFEST.yaml | Lists all projects in workspace |
| brain/DECISIONS.md | Architectural decision records |
| brain/CONTRACTS/ | API and interface contracts |
| brain/HANDOFFS/ | Work transition documents |
| brain/RULES/ | Coding standards and conventions |

## Guidelines

1. Read relevant brain files before making significant changes
2. Follow established patterns in the codebase
3. Document decisions in brain/DECISIONS.md
4. Update contracts when changing APIs
"""

    def _load_manifest(self) -> Optional[BrainManifest]:
        """Load and parse MANIFEST.yaml."""
        if not self.config.manifest_path.exists():
            return None

        try:
            content = self.config.manifest_path.read_text(encoding="utf-8")
            data = yaml.safe_load(content)

            if data is None:
                return None

            # Convert detected_projects from dict format
            projects_data = data.get("detected_projects", [])
            from workspacebrain.models import ProjectInfo

            projects = []
            for p in projects_data:
                detected_at = p.get("detected_at")
                if isinstance(detected_at, str):
                    detected_at = datetime.fromisoformat(detected_at)
                elif detected_at is None:
                    detected_at = datetime.now()

                # Support both "type" (new) and "project_type" (old) keys
                project_type = p.get("type") or p.get("project_type") or "unknown"

                projects.append(
                    ProjectInfo(
                        name=p["name"],
                        path=p["path"],
                        project_type=project_type,
                        confidence=p.get("confidence", 0.5),
                        signals=p.get("signals", []),
                        detected_at=detected_at,
                    )
                )

            created_at = data.get("created_at")
            if isinstance(created_at, str):
                created_at = datetime.fromisoformat(created_at)

            updated_at = data.get("updated_at")
            if isinstance(updated_at, str):
                updated_at = datetime.fromisoformat(updated_at)

            return BrainManifest(
                workspace_path=data["workspace_path"],
                brain_version=data.get("brain_version", "1.0"),
                created_at=created_at or datetime.now(),
                updated_at=updated_at or datetime.now(),
                detected_projects=projects,
            )

        except (yaml.YAMLError, KeyError, TypeError):
            return None


def unlink_project(project_path: Path) -> bool:
    """Remove .brain symlink/directory and AI rule files from a project."""
    removed = False

    # Remove .brain symlink or directory
    brain_pointer = project_path / BrainLinker.BRAIN_POINTER
    if brain_pointer.is_symlink():
        brain_pointer.unlink()
        removed = True
    elif brain_pointer.is_dir():
        import shutil
        shutil.rmtree(brain_pointer)
        removed = True

    # Remove generated AI rule files
    for rule_file in AI_RULE_FILES:
        rule_path = project_path / rule_file
        if rule_path.exists():
            # Only remove if it has our generated banner
            content = rule_path.read_text(encoding="utf-8")
            if "GENERATED BY WORKSPACEBRAIN" in content:
                rule_path.unlink()
                removed = True

    return removed
